"""
Okta User Sync Middleware for Django

Syncs Okta authenticated users to local database after JWT validation.
Implements the same logic as Spring Boot's OktaUserSyncFilter.

If email is missing from JWT, falls back to Okta userinfo endpoint.
"""

import os
import logging
import fnmatch
import requests
from django.conf import settings
from django.http import JsonResponse
from app_rbac.models import User, UserRole


logger = logging.getLogger(__name__)


class OktaUserSyncMiddleware:
    """
    Middleware that syncs Okta users to the local database.

    Flow:
    1. Runs after JWT authentication (authentication.py)
    2. Checks if request has authenticated user (from JWT)
    3. Extracts user information from JWT payload
    4. Upserts user to database with role assignment
    5. Returns HTTP 500 if sync fails (fail fast)

    Environment variables for admin role assignment:
    - APP_USERS_ROOT: Single root user email (gets ROOT, ADMIN, USER roles)
    - APP_USERS_ADMINS: Comma-separated admin emails (get ADMIN, USER roles)
    """

    def __init__(self, get_response):
        self.get_response = get_response
        self.root_user = os.environ.get('APP_USERS_ROOT', '').strip()
        admins_str = os.environ.get('APP_USERS_ADMINS', '').strip()
        self.admin_users = [email.strip() for email in admins_str.split(',') if email.strip()]

    def __call__(self, request):
        # Skip public endpoints defined in settings.PUBLIC_URIS
        if self._is_public_path(request.path):
            return self.get_response(request)

        # Only sync if user is authenticated via Okta
        if hasattr(request, 'user') and hasattr(request.user, 'payload'):
            try:
                self._sync_user_to_database(request.user)
            except Exception as e:
                logger.error(f'Failed to sync Okta user to database. Failing request: {str(e)}', exc_info=True)
                return JsonResponse(
                    {
                        'error': 'User synchronization failed',
                        'message': str(e)
                    },
                    status=500
                )

        return self.get_response(request)

    def _is_public_path(self, path):
        """
        Check if the given path matches any public URI pattern.
        Reads from settings.PUBLIC_URIS (list of URI patterns).
        """
        public_uris = getattr(settings, 'PUBLIC_URIS', [
            '/',
            '/api/v1/public/*',
            '/health',
            '/admin/*',
            '/static/*',
            '/media/*',
        ])

        for pattern in public_uris:
            # Convert pattern to fnmatch-compatible (simple wildcard matching)
            if fnmatch.fnmatch(path, pattern):
                return True
            # Also check exact match
            if path == pattern:
                return True

        return False

    def _sync_user_to_database(self, okta_user):
        """
        Synchronize Okta user to local database with role assignment.

        Args:
            okta_user: OktaUser object from authentication.py with payload
        """
        payload = okta_user.payload
        access_token = getattr(okta_user, 'token', None)

        # Extract user information from JWT
        email = payload.get('email') or payload.get('preferred_username')
        okta_id = payload.get('sub')  # Okta user ID
        first_name = payload.get('given_name')
        last_name = payload.get('family_name')
        name = payload.get('name')
        picture = payload.get('picture')

        # Fallback to Okta userinfo endpoint if email is missing from JWT
        if not email and access_token:
            logger.warning('Email claim missing from JWT token, falling back to Okta userinfo endpoint')
            userinfo = self._fetch_userinfo_from_okta(access_token)
            email = userinfo.get('email')
            if not first_name:
                first_name = userinfo.get('given_name')
            if not last_name:
                last_name = userinfo.get('family_name')
            if not name:
                name = userinfo.get('name')
            if not picture:
                picture = userinfo.get('picture')

        if not email:
            raise ValueError('Email not available from JWT claims or Okta userinfo endpoint')

        # If firstName/lastName are blank but name is available, parse it
        if not first_name and name:
            name_parts = name.split(' ', 1)
            first_name = name_parts[0]
            if len(name_parts) > 1:
                last_name = name_parts[1]

        # Extract tenant ID from custom claim if configured
        {{#tenantIdClaimKey}}
        tenant_claim_key = getattr(settings, 'OKTA_TENANT_CLAIM_KEY', '{{tenantIdClaimKey}}')
        tenant_id = payload.get(tenant_claim_key) if tenant_claim_key else None
        {{/tenantIdClaimKey}}
        {{^tenantIdClaimKey}}
        tenant_id = None
        {{/tenantIdClaimKey}}

        logger.debug(f'Syncing Okta user to database: email={email}, okta_id={okta_id}, tenant_id={tenant_id}')

        # Determine roles based on email
        roles = [UserRole.USER]
        if self.root_user and self.root_user.lower() == email.lower():
            logger.warning(f'Creating root user: {email}')
            roles = [UserRole.ROOT, UserRole.ADMIN, UserRole.USER]
        elif any(admin.lower() == email.lower() for admin in self.admin_users):
            logger.warning(f'Creating admin user: {email}')
            roles = [UserRole.ADMIN, UserRole.USER]

        # Upsert user to database
        user, created = User.objects.update_or_create(
            external_auth_provider='okta',
            external_auth_id=okta_id,
            defaults={
                'tenant_id': tenant_id,
                'username': email,  # Username same as email
                'email': email,
                'first_name': first_name,
                'last_name': last_name,
                'picture': picture,
                'enabled': True,
                'roles': roles,
                'deleted': False,
            }
        )

        action = 'Created' if created else 'Updated'
        logger.info(f'{action} user: {email} with roles: {roles}')

    def _fetch_userinfo_from_okta(self, access_token):
        """
        Fetches user info from Okta userinfo endpoint using the access token.
        This is used as a fallback when email claim is not present in the JWT.

        Args:
            access_token: The user's access token

        Returns:
            dict: User info containing email, given_name, family_name, picture
        """
        okta_issuer = getattr(settings, 'OKTA_ISSUER', '')
        if not okta_issuer:
            raise ValueError('OKTA_ISSUER not configured in settings')

        # Okta userinfo endpoint: {issuer}/v1/userinfo
        userinfo_url = f'{okta_issuer}/v1/userinfo'
        logger.debug(f'Fetching user info from Okta: {userinfo_url}')

        try:
            response = requests.get(
                userinfo_url,
                headers={'Authorization': f'Bearer {access_token}'},
                timeout=10
            )
            response.raise_for_status()
            userinfo = response.json()
            logger.debug(f'Successfully fetched user info from Okta: email={userinfo.get("email")}')
            return userinfo
        except requests.RequestException as e:
            logger.error(f'Failed to fetch user info from Okta userinfo endpoint: {str(e)}')
            raise RuntimeError(f'Failed to fetch user info from Okta: {str(e)}')
